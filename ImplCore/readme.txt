Что если строить дерево за один проход по коллекции инпутов?

Мы будем строить дерево, чтобы проверить наличие цикла или multiple roots.
Ребра с ошибкой "more than two children" будем игнорировать с пометкой "такая ошика встретилась". Продолжим строить дерево. Даже если эти элементы
будут участвовать в цикле, такая ошибка имеет больший приоритет и нам необязательно находить цикл. Фактически, после нахождения одного такого элемента
задача будет сводиться к нахождению ребер-дубликатов.

Нужно будет иметь:
a) связанный список для хранения текущих вершин. Это будет список поддеревьев. Каждый следующий элемент будет либо добавляться в существующее поддерево,
либо становиться вершиной нового поддерева. Эти поддеревья будут постепенно объединяться в одно.
b) словарь значение вершины - элемент связанного списка. Нужен для быстрого объединения двух поддеревьев.

Вместо a) и b) может быть один словарь "значение вершины - узел". Тогда, после поглощения одного поддерева другим, элемент словаря поглощенной вершины будет
иметь значение Null. Это будет означать, что когда-то элемент был вершиной поддерева. Такие элементы больше не представляют интерес и будут игнорироваться.

c) словарь всех уже обработанных значений. Нужен для быстрого добавления элемента к родителю или создания новой вершины.
d) некая структура для хранения информации о наличии связи между двумя поддеревьями. Такая информация нужна для того, чтобы фиксировать наличие цикла при
появлении еще одной связи(см. ниже про циклы). Эта структура должна обновляться при объединении поддеревьев.

Цикл будет возникать в двух случаях:
1) Внутрь поддерева добавляется элемент со ссылкой на элемент, уже находящийся в этом поддереве.
2) Если между двумя поддеревьями уже была связь (между уровнями ниже вершины) и появилась еще одна. ДВе связи означают цикл.

Т.е. нам нужно знать, в какое поддерево мы добавляем элемент. Значит "словарь всех уже обработанных значений" должен быть специфическим для каждого поддерева
и объединяться при объединении поддеревьев.

Структура со связями между поддеревьями тоже должна обновляться при объединении поддеревьев.
Например, A -> B -> C и B -> D. Если C поглощает B, то новые связи будут: A -> C -> D. Т.е. на тех, на кого ссылалось B теперь ссылается C, и на C ссылаются те,
кто ссылался на B.

